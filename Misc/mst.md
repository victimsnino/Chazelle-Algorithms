### Минимальное остовное дерево

#### Краткое описание
* На вход подается связный, неориентированный граф без ребер "в себя", где для каждого ребра _e_ есть _вес c(e)_
* Веса - различные элементы и отсортированного универса
* В таком случае MST - единственен

#### Термины
Подграф C графа G называется стягиваемыем, если его пересечение с MST(G) связно. В результате MST(G) может быть собрано напрямую из MST(C) и MST(G'), где G' - граф G со стянутым C в одну вершину.

Предыдущие алгоритмы находят стягиваемые подграфы на лету по меру того, как исследованная часть MST растет. Идея данного алгоритма вывернуть процесс:  определеять стягиваемость C до вычисления MST. Преимущество: найти MST(C) намного ппроще, если мы уже знаем, что C - стягиваемый: нам просто необходимо иучать только те ребра, обе вершины которых находятся внутри C. Иначе же мы должны рассматривать ребра с одной вершиной в C. "Разделяй и властвуй". Главная проблема: Как определить стягиваемость подграфа до подсчета MST? Вот зачем нужны soft-heaps.

__Для подсчета MST(G)__:
1) Разбиваем граф G на вершинно не пересекающиеся подграфы подходтящего размера (то есть персечение любых двух подграфов - пустота)
2) Стягиваем каждый подграф в одну вершину. В итоге из графа G получаем минор - граф полученный после последовательности стягиваний каждого подграфа (каждая вершина - стянутый подграф).
3) Повторяем пункты 1 и 2 пока не останется всего 1 вершина.

<br>
Подобная иерархия стягиваемых подграфов  может быть легко представлена в виде идеально сбалансированного дерева T:

* листы - вершины графа G
* внутренние вершины Z с детьми Zi - граф Cz чьи вершины - "стяжки" графов C{Zi}.
* Каждый уровень T соответсвует минору G и каждый Cz - стянутый подграф миноров-детей.
* Уровень листов - изначальный граф
* Корень - граф G, стянутый в одну вершину.

Когда T получен, MST каждого Cz может быть подсчитан рекурсивно. так как Cz-ые - стягиваемые, то объединение всех MST(Cz) является MST(G).

У нас есть полная свобода по выбору высоты d дерева T и количеству вершин nz в кажом  Cz (которое, такжже, является количеством детей вершины z в дереве). Дерево T можно найти за время O(m+d^3*n).

_Если d большое, то:_
* nz-ые остаются достаточно маленькими
* рекурсивный подсчет каждого Cz очень быстрый
* построение всего дерева - медленно

_Иначе (при d маленьком)_
* Быстрое построение всего дерева
* Cz-ые стновятся большими
* Рекурсивный подсчет долгий

Для разрешения этой ситуации и нужна функция аккермана, которая находит оптималльное соотношение

Пусть dz - высота вершины z в дереве T (максимальное количество ребер от z до листа). Разумный выбор __nz = S(t, 1)^3 = 8__ если dz = 1 и __nz = S(t -1, S(t, d-1))^3__ если dz > 1, при t > 0 минимум будет, что __n <= S(t, d)^3 при d = c<округление вверх>(m/n^(1/3))__ при достаточно большой константе c
__S__:
* S(1, j) = 2j, j > 0
* S(i, 1) = 2, i > 0
* S(i, j) = S(i,j-1)S(i-1,S(i,j-1))

__to-do__

#### Повреждение ребер
В процессе построения T некоторые ребра графа G могут стать поврежденными, то есть, их вес увеличится (иногда даже более 1 раза). Причина - мягкие кучи (она используется для определения стягиваемые подграфов). Некоторые поврежденные ребра -проблема, а некоторые нет. Это связано с тем, каков порядок построения T.

Интуитивно кажется, что строить надо снизу вверх, но это ошибка, так как важно поддерживать связную структуру. Поэтому мы будем строить T наоборот: сначала дети, затем родители.

Пусть z - текущая вершина, рассматриваемая в T. Пусть z1,..., zk = z - __текущий пусть__ из корня z1. Тогда подграфы Cz1, ..., Czk - в данный момент собираются, посколько как только Czk будет стянут в одну вершину, она будет добавлена в Czk-1. 

_Маленькое техническое замечание: пусть zi+1 - левый потомок zi, то есть, первый ребенок в хронологическом порядке, тогда Czi еще не имеет ни одной вершины в данный момент. Поэтому вполне разумо исключить ее из текущего пути. Преимуещство в том, что мы избегаем одно-детных родителей и таким образом все Cz1, ..., Czk в данный момент имеют хотя бы 1 вершину, которая является вершиной в G или стянутым связным подграфом._

__Пограничным ребром__ (ребро пограничного типа) из G называется такое ребро, которое имеет ровно одну вершину из подграфа Cz1 U ... U Czk. Конечно, тип ребер меняется каждый раз (successively,  unvisited,  border, принадлежащий Cz along  active  path,  contracted).Повреждаться могут только пограничные ребра (так как они уже в мягкой куче).

На первый взгляд повреждения - фатальная проблема , так как если повредяться все ребра, мы решим MST с неправильными весами ребер. Однако, поврежденя становятся проблемой лишь в одном особом случае: назовем ребро __плохим__, если это поврежденное пограничное ребро в то время, как оно принасдлежит подграфу Cz, который стянут в одну вершину. Это можно доказать, что если даже ни одно ребро не стнет плохим, алгоритм будет действовать как если бы ни одного повреждения не произошло независимо от их фактического количества. В результате наша цель бороться с появлением плохих ребер, а не поврежденных. Мы можем зафиксировать количество плохих  ребер на уровне m/2 + d^3*n. количество же поврежденных (но не плохих) не имеет значения

После того, как T построен, мы восстанавливаем ребрам их оригинальные веса и удаляем все плохие ребра. Рекурсивно используем то, что остается от Cz-ых для создания остовного леса F. После этого мы возвращаемся к плохими ребрам и вновь рекурсивно строим MST(G). В этих разных рекурсиях есть небольшие тонкости. 


#### Алгоритм