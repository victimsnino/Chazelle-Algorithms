### Минимальное остовное дерево

#### Краткое описание
* На вход подается связный, неориентированный граф без ребер "в себя", где для каждого ребра _e_ есть _вес c(e)_
* Веса - различные элементы и отсортированного универса
* В таком случае MST - единственен

#### Термины
Подграф C графа G называется стягиваемыем, если его пересечение с MST(G) связно. В результате MST(G) может быть собрано напрямую из MST(C) и MST(G'), где G' - граф G со стянутым C в одну вершину.

Предыдущие алгоритмы находят стягиваемые подграфы на лету по меру того, как исследованная часть MST растет. Идея данного алгоритма вывернуть процесс:  определеять стягиваемость C до вычисления MST. Преимущество: найти MST(C) намного ппроще, если мы уже знаем, что C - стягиваемый: нам просто необходимо иучать только те ребра, обе вершины которых находятся внутри C. Иначе же мы должны рассматривать ребра с одной вершиной в C. "Разделяй и властвуй". Главная проблема: Как определить стягиваемость подграфа до подсчета MST? Вот зачем нужны soft-heaps.

__Для подсчета MST(G)__:
1) Разбиваем граф G на вершинно не пересекающиеся подграфы подходтящего размера (то есть персечение любых двух подграфов - пустота)
2) Стягиваем каждый подграф в одну вершину. В итоге из графа G получаем минор - граф полученный после последовательности стягиваний каждого подграфа (каждая вершина - стянутый подграф).
3) Повторяем пункты 1 и 2 пока не останется всего 1 вершина.

<br>
Подобная иерархия стягиваемых подграфов  может быть легко представлена в виде идеально сбалансированного дерева T:

* листы - вершины графа G
* внутренние вершины Z с детьми Zi - граф Cz чьи вершины - "стяжки" графов C{Zi}.
* Каждый уровень T соответсвует минору G и каждый Cz - стянутый подграф миноров-детей.
* Уровень листов - изначальный граф
* Корень - граф G, стянутый в одну вершину.

Когда T получен, MST каждого Cz может быть подсчитан рекурсивно. так как Cz-ые - стягиваемые, то объединение всех MST(Cz) является MST(G).

У нас есть полная свобода по выбору высоты d дерева T и количеству вершин nz в кажом  Cz (которое, такжже, является количеством детей вершины z в дереве). Дерево T можно найти за время O(m+d^3*n).

_Если d большое, то:_
* nz-ые остаются достаточно маленькими
* рекурсивный подсчет каждого Cz очень быстрый
* построение всего дерева - медленно

_Иначе (при d маленьком)_
* Быстрое построение всего дерева
* Cz-ые стновятся большими
* Рекурсивный подсчет долгий

Для разрешения этой ситуации и нужна функция аккермана, которая находит оптималльное соотношение

Пусть dz - высота вершины z в дереве T (максимальное количество ребер от z до листа). Разумный выбор __nz = S(t, 1)^3 = 8__ если dz = 1 и __nz = S(t -1, S(t, d-1))^3__ если dz > 1, при t > 0 минимум будет, что __n <= S(t, d)^3 при d = c<округление вверх>(m/n^(1/3))__ при достаточно большой константе c
__S__:
* S(1, j) = 2j, j > 0
* S(i, 1) = 2, i > 0
* S(i, j) = S(i,j-1)S(i-1,S(i,j-1))

__to-do__

#### Повреждение ребер
В процессе построения T некоторые ребра графа G могут стать поврежденными, то есть, их вес увеличится (иногда даже более 1 раза). Причина - мягкие кучи (она используется для определения стягиваемые подграфов). Некоторые поврежденные ребра -проблема, а некоторые нет. Это связано с тем, каков порядок построения T.

Интуитивно кажется, что строить надо снизу вверх, но это ошибка, так как важно поддерживать связную структуру. Поэтому мы будем строить T наоборот: сначала дети, затем родители.

Пусть z - текущая вершина, рассматриваемая в T. Пусть z1,..., zk = z - __текущий пусть__ из корня z1. Тогда подграфы Cz1, ..., Czk - в данный момент собираются, посколько как только Czk будет стянут в одну вершину, она будет добавлена в Czk-1. 

_Маленькое техническое замечание: пусть zi+1 - левый потомок zi, то есть, первый ребенок в хронологическом порядке, тогда Czi еще не имеет ни одной вершины в данный момент. Поэтому вполне разумо исключить ее из текущего пути. Преимуещство в том, что мы избегаем одно-детных родителей и таким образом все Cz1, ..., Czk в данный момент имеют хотя бы 1 вершину, которая является вершиной в G или стянутым связным подграфом._

__Пограничным ребром__ (ребро пограничного типа) из G называется такое ребро, которое имеет ровно одну вершину из подграфа Cz1 U ... U Czk. Конечно, тип ребер меняется каждый раз (successively,  unvisited,  border, принадлежащий Cz along  active  path,  contracted).Повреждаться могут только пограничные ребра (так как они уже в мягкой куче).

На первый взгляд повреждения - фатальная проблема , так как если повредяться все ребра, мы решим MST с неправильными весами ребер. Однако, поврежденя становятся проблемой лишь в одном особом случае: назовем ребро __плохим__, если это поврежденное пограничное ребро в то время, как оно принасдлежит подграфу Cz, который стянут в одну вершину. Это можно доказать, что если даже ни одно ребро не стнет плохим, алгоритм будет действовать как если бы ни одного повреждения не произошло независимо от их фактического количества. В результате наша цель бороться с появлением плохих ребер, а не поврежденных. Мы можем зафиксировать количество плохих  ребер на уровне m/2 + d^3*n. количество же поврежденных (но не плохих) не имеет значения

После того, как T построен, мы восстанавливаем ребрам их оригинальные веса и удаляем все плохие ребра. Рекурсивно используем то, что остается от Cz-ых для создания остовного леса F. После этого мы возвращаемся к плохими ребрам и вновь рекурсивно строим MST(G). В этих разных рекурсиях есть небольшие тонкости. 


#### Алгоритм
##### Фаза Борувки:
Для каждой вершины находим самое "легкое" (наименьшее по весу) ребро и стягиваем его. Таким образом все "не остовные" ребра останутся на месте. Алгоритм:
* Для каждой вершины находим наименьшее по весу ребро (в хронологическом порядке по вершинам) (ребро может быть выбрано несколько раз)
* Стягиваем все выбранные ребра, добавляем их в остновное дерево.

##### Шаги Алгоритма
1) Если входной параметре t == 1 или o(n), то считаем Борувкой
2) Применяем __Фазу Борувки__ _с_ раз.
3) _Построение дерева T._ При t > 1, для каждой Cz целевой размер nz = S( t -1, S(t, dzk - 1))^3, где dzk - высота z.

Итак, пусть у нас есть z1, .., zk = z - текущий путь. Подграфы Cz1, .., Czk - сейчас конструируются и связаны ребрами, веса которых уменьшаются (Figure 1). Алгоритм в ходе работы __"отбрасывает"__ некоторые ребра из графа G0(это значит, что они просто исключаются из расмотрения). Каждый подграф Cz включает все не отброшенные ребра графа G0, чьи концы входят в него. Поэтому для опрделения Cz достаточно указать входящие в него вершины. G0 - это оригинальный граф G0 без учета ранее отброшенных ребер.

__Рабочий вес__ - в любой момент времени рабочий вес - это текущий вес если ребро плохое, и оригинальный вес в противном случае. Таким образом у нас имеется 3 вида весов: оригинальные, текущие и рабочие.

#### (???????)
Варианты ситуация в подграфах:
1) Для всех i < k мы храним ребро (которое зовется __цепной связью__), соединяющее Czi с Czi+1, чей текущий вес:
   1) Максимум всех пограничных ребер, инцедентных Cz1 U ... U Czi
   2) Меньше чем рабочие веса любых ребер, соединяющих два (distinct) Czj's (j <= i). (Для этого мы храним min-link, если такое есть, для каждой пары i < j: это такое ребро минимального рабочего веса, соединяющзее Czi и Czj)
2) Для всех j, для которых есть пограничные ребра (u,v), такие что u принадлежит Czj хранятся либо в мягкой куче H(i) или в одной H(i, j), где 0 <= i < j. Более чем в  одной куче ребра не хранятся. Помимо условия _u принадлежит Czj_, нахождение в куче H(j) означает, что вершина v соединена как минимум с одним ребром в некотором H(i, j); нахождение в H(i, j) также  означает, что v смежен Czi, но , но не с любым Czl (i < l < j). Можно расширить это до i = 0, что значит, что v смежен не Czl (l < j). Все мягкие кучи имеют коэфф. ошибки 1/c.

Основная идея пункта №1: указать, что текущий путь соответствует убывающей (в плане веса) цепочке ребер связывающих разные Cz-ые. Это убывающее свойство необходимо для стягиваемости. Цепная связь между Czi и Czi+1 - это ребро, которое делает его первой вершиной Czi+1. Последовательно, по мере роста Czi+1 более дешевые ребра могут соединять его с Czi и, поэтому, цепная связь, скорее всего, будет  отличаться от min-link между Czi и Czi+1.

Зачем нужно столько мягких куч? Для того, чтобы бороться с плохими ребрами. Когда мы удаляем плохое ребро из мягкой кучи, теорема 1.2 позволяет заново произвести столько же повреждений. Эти новые испорченные ребра могут стать плохими и быть удален. Цикличность процесса может привести к ужасным последствиям даже если было одно плохо ребро. Поэтому мы используем нессколько куч для создания эффекта буфферизация для противостояния этому процессу. Этот процесс основан на структуре MST и взаимодействии куч.

Дерево T строится в поступорядоченном порядке, основаномо на стеке, который имеет лишь операции пуш/поп, который соответвуют расширению и уменьшеню акивного пути.
* __Уменьшение__. Оно происходит для k >=2 когда последний подграф Czk достигает своего целевого размера, то есть, число nzk вершин достигает значения S(t -1, S(t, dzk-1))^3, где Dzk - высота zk в T. Заметим, что целевой размер также число детей zk в T. В частном случае Dzk =1 целевой размер равен _S(t, 1)^3 = 8_. Подграф Czk стягивается и становится новой вершиной в подграфе Czk-1. Эта вершина соединяется к Czk-1 с помощью цепной связи (плюс, возможно, другими ребрами)  между Czk-1 и (теперь стянутым) Czk: эти ребра не стягиваемы. 
В результате  Czk-1 разрастается новой вершиной и как минимум одним (или несколькими) новым ребром и конец активного пути переходит в zk-1. 
Маленькое техническое замечаение: так как мы ранее указали, что избегаем нулевых по весу вершин в активном пути Cz-ых, мы должны добавить вершину между zk-1 и zk в случае, когда их высоты различаются более, чем на единицу. (Подразумевается нумерация Cz-ых и не требует обновлений: высота понимается в смысле полного, а не частичного построенного дерева T). Удоветворение инварианта 1 в O(k) время просто, а вот инварианта 2 уже меньше. Вот почему:
Кучи H(k) и H(k-1, k) разрушены. Все испорченные ребра отброшены. (Заметим, что такие ребра если не были плохими, станут ими сейчас). Оставшиеся итемы (?) сгруппированы в подмножеста (называемые __кластерами__) ребер, которые разделяют общие концы вне цепи. Для каждого кластера, в свою очередь, выбирается ребро (r, s) минимальной цены и отбрасываются остальные (Если они есть). Далее, вставляем выбранное ребро в кучу, подразумеваемую в инварианте 2. В частноти, если (r, s) пришло из H(k) и разделяет s с ребром в H(k-1, k) или если оно пришло из H(k-1, k), тогда по инварианту 2 оно также разделяет s с ребром в некотором H(i, k-1) и оно может быть вставлено в H(k-1). Иначе (r,s) пришло из H(k) и,поэтому, по инварианту 2 оно разделяет s с ребром в некотором H(i, k) с текущим i < k-1. Ребро (r,s) следует вставить  в H(i,k). В конце концов для каждого i < k-1 сливаем H(i, k) в H(i, k-1).
Два уточнения:
   * При вставке (r,s) в H(i, k) мы вынуждаем вставить в кучу как минимум второе ребро, указывающее на s
   * Поскольку H(i, k) сливается в H(i, k-1) мы можм вставить (r,s) в H(k-1) вместо H(i, k) и остается удовлетворить инварианту2. Мы выбираем нет, поскольку есть риск увидеть ребро прыгающее между H(*)ыми в каждом уменьшении которое может быть дорогим.
* __Расширение__. Делаем findmin на _всех_ кучах и получаем пограничные ребра (u, v) минимального текущего веса c(u,v). Назовем его расширяющим ребром. Среди всеъ минмальныъ связей рабочих весов не более, чем c(u,v) найдем одно (a,b) инцедентное к Czi минимального индекса i. Если такое ребро существует, мы выполняем __сплав__: мы стягиваем всю цепочку Cz+1 U ... U Czk в a. Лучше думать об этом как двухэтапном процессе:
   1) Стягиваем все ребра с обеими концами  в Czi+1 U ... U Czk. Назовем b __результирующей вершиной__ и стянем ребра соединяющие a и b. 
   2) Обновляем все релевантные минимальные связи, которые легко делаются за O(k^2) время. Для обновления куч мы обощим расширяющий процесс в следующей манере: Мы распротрняем (extend) разрушение куч, чтобы включить не только H(k) и H(k-1, k), но и H(i+1),...,H(k) и все H(j, j'), i <= j < j'. Для начала мы отбрасываем все испорченные ребра из этих куч поскольку они теперь плохие. Затем перегрупируем оставшиеся ребра в кластеры и для каждого из них мы передобавляем ребро (r,s) минимального текущего веса и отбрасываем остльные. Как и ранее, мы имеем два разных случая:

