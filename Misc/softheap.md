# Softheap
Мягкая куча - последовательность модифицированных биномиальных деревьев различных рангов, называемых _мягкие очереди_. Модификации включают в себя:
* ***Мягкая очередь q*** - биномиальное дерево, поддеревья которого, возможно, отсутствуют. 
Биномиальное дерево, из которого построена мягкая очередь, называется ___мастер-деревом___. 
___Ранг___ вершины q - это количество детей у соответствующей вершины в мастер-дереве. Очевидно, это верхняя граница на количество детей для вершины q. 
Гарантируется следующее: количество детей у вершины должно быть не меньше, чем _"округление вниз от (ранг(q)/2)"_.
* Узел ___v___ хранит в себе односвязный список элементов. Поле **ckey** узла v является общим значением всех текущих ключей элементов из списка _(max????)_ (верхней границей оригинальных ключей). Мягкая очередь обладает кучеобразнастью по полю **ckey** - это значит, что **ckey** узла не превышает **ckey** любого из детей. 
Введем параметр r = r(e) и будем требовать, чтобы все испорченные элементы лежали бы в узлах, чей ранг больше, чем r.

У узла есть поля ckeys и ранг в соответствущем мастер-дереве. Поля _next_ и _child_ используются для доступа к детям. Текущий узел для Child - родитель мягкой очереди ранга на 1 меньше, для Next - корень мягкой очереди ранга на 1 меньше. Такая уловка используется для представления высоко-степенных улов в виде последовательности узлов степени 2. Также у нас имеется список элементов внутри узла.

В общем виде куча представляется в виде двусвязного корневого списка h1...hm. Каждый корень hi имеет два дополнительных указателя: один указывает на корень очереди (Ri) (queue), а другой на корень (Rj) (suffix_min) с минимальным ckey среди всех Rj'ых (j>=i). Требуется, чтобы ранг(R1)< ... < ранг(Rm) (В корневом списке каждая последующая очередь имеет более высокий ранг). Ранг очереди  - ранг корня. Это значение хранится в корне очереди. Ранг кучи - максимальный из рангов очередей.

# Методы
### Инициализация:
* Head - корень 
* Tail - хвост с бесконечным рангом.
* r = R(e)

```c++
head *header, *tail; 
int r;
header = new_head(); 
tail   = new_head(); 
tail->rank=INFTY; 
header->next = tail;
tail->prev = header;
printf (“Enter r:”); 
scanf (“%d”, &r);
```

### Удаление
Может быть заимплеменчено в ленивой форме: помечаем, что узел надо удалить, но удаляем фактиччески, когда findmin попытается его вернуть.

### Вставка
* Создаем одно-ущловую очередь
* Объединяем с кучей
```c++
insert(int newkey)
{
    node *q;
    ilcell *l;
    l = (ilcell *)malloc(sizeof(ilcell));
    l->key = newkey;
    l->next = NULL;
    q = new_node();
    q->rank = 0;
    q->ckey = newkey;
    q->il = l;
    q->il_tail = l;
    meld(q)
}
```

### Объединение двух куч
* Пусть у нас есть две кучи A1 и A2. 
* Пусть куча A2 имеет меньший ранг и мы будем встраивать каждую из ее очердей в кучу A1. 
* Для того, чтобы встроить очередь ранга K в кучу A1:
    *  Мы смотрим на наименьший такой индекс i, где ранг очереди Ri >=K. (Пустой хвост подразумевает, что i всегда есть)
    *  Если ранг Ri > K, мы вставляем  очередь прям перед этой очередью (~~ нет очереди с таким рангом, так что спокойно вставляемся)
    *  Иначе объединяем две очереди в очередь ранга K+1 путем превращения корня с наибольшим ключом ребенком другого корня. Повторяем процесс объединения для новой очереди
*  После вставки обновляем значение поля suffix_min для всех очередей от первой до последней посещенной (меньших по индексу, так как suffix_min всегда смотрит "вправо") (в случае объединения куч, а не очередей можно сделать это в сааааамом конце)
```c++
meld(node *q)
{
    /* 1) Scan head-list to find place where to place new queue */
    head *tohead = header->next;
    while (q->rank > tohead->rank)
        tohead = tohead->next;

    head* prevhead = tohead->prev;

    /* 2) If new place rank == rank(q), then merge them */
    node *top, *bottom;
    while (q->rank == tohead->rank)
    {
        if (tohead->queue->ckey > q->ckey)
        {
            top = q;
            bottom = tohead->queue;
        }
        else
        {
            top = tohead->queue;
            bottom = q;
        }
        q = new_node();
        q->ckey = top->ckey;
        q->rank = top->rank + 1;
        q->child = bottom;
        q->next = top;
        q->il = top->il;
        q->il_tail = top->il_tail;
        tohead = tohead->next;
    }
    /* 3) Actually insert.. */
    head* h;
    if (prevhead == tohead->prev)
        h = new_head();
    else // actually we've moved out queue from this one...
        h = prevhead->next;
    h->queue = q;
    h->rank = q->rank;
    h->prev = prevhead;
    h->next = tohead;
    prevhead->next = h;
    tohead->prev = h;
    // restore suffix_min
    fix_minlist(h);
    }
```

### Исправление suffix_min
Предполагается, что некорректны только поля между корнем и h
```c++
fix_minlist(head *h)
{
    head *tmpmin;
    if (h->next == tail)
        tmpmin = h;
    else
        tmpmin = h->next->suffix_min;
    while (h != header)
    {
        if (h->queue->ckey < tmpmin->queue->ckey)
            tmpmin = h;
        h->suffix_min = tmpmin;
        h = h->prev;
    }
}
```
